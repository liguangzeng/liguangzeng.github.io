(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{276:function(t,a,e){"use strict";e.r(a);var r=e(4),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("文章内容根据"),e("a",{attrs:{href:"https://mp.weixin.qq.com/s/9yibACTP1sTAn16jeWueOQ",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://mp.weixin.qq.com/s/9yibACTP1sTAn16jeWueOQ"),e("OutboundLink")],1),t._v("学习。")]),t._v(" "),e("h2",{attrs:{id:"堆与栈-stack-heap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#堆与栈-stack-heap"}},[t._v("#")]),t._v(" 堆与栈（Stack & Heap）")]),t._v(" "),e("blockquote",[e("p",[t._v("内存通常指的是操作系统从主存中划分（抽象）出来的内存空间。\n内存又可以分为两类：栈内存和堆内存。")])]),t._v(" "),e("h3",{attrs:{id:"栈内存-stack-memory"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#栈内存-stack-memory"}},[t._v("#")]),t._v(" 栈内存（stack memory）")]),t._v(" "),e("p",[t._v("栈内存遵循着后进先出的原则，生活中的例子可以参考羽毛球桶，因此栈内存读取会非常的快。但是栈内存一般容量较小主要用于\n存放函数调用信息和变量等数据，大量的内存操作会导致栈溢出。简单来说，"),e("code",[t._v("栈内存适合存放生命周期短、占用空间小且固定的数据")]),t._v("。工作有些忙晚些继续")]),t._v(" "),e("h3",{attrs:{id:"堆内存-heap-memory"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#堆内存-heap-memory"}},[t._v("#")]),t._v(" 堆内存（Heap memory）")]),t._v(" "),e("p",[t._v("堆内存的分配是动态且不连续的，程序可以按需申请堆内存空间，但是访问速度要比栈内存慢不少。")]),t._v(" "),e("p",[t._v("堆内存里的数据可以长时间存在，无用的数据需要程序主动去回收，如果大量无用数据占用内存就会造成内存泄露（Memory leak）。\n"),e("code",[t._v("堆内存适合存放生命周期长，占用空间较大或占用空间不固定的数据。")])]),t._v(" "),e("h3",{attrs:{id:"函数调用-function-calling"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数调用-function-calling"}},[t._v("#")]),t._v(" 函数调用（Function calling）")]),t._v(" "),e("p",[t._v("当函数调用时，会将函数推入栈内存，生成一个栈帧（Stack frame），栈帧可以理解为由函数返回地址、\n参数和局部变量组成的一个块；当函数调用另一个函数时，又会将另一个函数推入栈内存中，周而复始；\n直到最后一个函数返回，便从栈顶开始将栈内存中的元素逐个弹出，直到栈内存中不再有元素时则此次调用结束。\n如下图。")]),t._v(" "),e("img",{attrs:{src:t.$withBase("/img/stack.gif"),alt:"调用帧"}}),t._v("     \n图中的内容经过了简化，剥离了栈帧的各种指针的概念，主要展示函数调用以及内存分配的大概过程。\n")])}),[],!1,null,null,null);a.default=s.exports}}]);