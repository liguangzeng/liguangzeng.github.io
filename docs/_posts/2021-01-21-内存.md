---
title: 内存分析
date: 2021-01-21 (日期)
tags:  (标签)
  - 内存
  - 堆
  - 栈
  - 垃圾回收
author: lgz (作者)
location: 郑州 (位置)
---
文章内容根据[https://mp.weixin.qq.com/s/9yibACTP1sTAn16jeWueOQ](https://mp.weixin.qq.com/s/9yibACTP1sTAn16jeWueOQ)学习。
## 堆与栈（Stack & Heap）
>内存通常指的是操作系统从主存中划分（抽象）出来的内存空间。
内存又可以分为两类：栈内存和堆内存。
### 栈内存（stack memory）
栈内存遵循着后进先出的原则，生活中的例子可以参考羽毛球桶，因此栈内存读取会非常的快。但是栈内存一般容量较小主要用于
存放函数调用信息和变量等数据，大量的内存操作会导致栈溢出。简单来说，`栈内存适合存放生命周期短、占用空间小且固定的数据`。工作有些忙晚些继续

### 堆内存（Heap memory）
堆内存的分配是动态且不连续的，程序可以按需申请堆内存空间，但是访问速度要比栈内存慢不少。  

堆内存里的数据可以长时间存在，无用的数据需要程序主动去回收，如果大量无用数据占用内存就会造成内存泄露（Memory leak）。
`堆内存适合存放生命周期长，占用空间较大或占用空间不固定的数据。`

### 函数调用（Function calling）
  当函数调用时，会将函数推入栈内存，生成一个栈帧（Stack frame），栈帧可以理解为由函数返回地址、
  参数和局部变量组成的一个块；当函数调用另一个函数时，又会将另一个函数推入栈内存中，周而复始；
  直到最后一个函数返回，便从栈顶开始将栈内存中的元素逐个弹出，直到栈内存中不再有元素时则此次调用结束。
   如下图。    
   
<img :src="$withBase('/img/memory/stack.gif')" alt="调用帧">     
图中的内容经过了简化，剥离了栈帧的各种指针的概念，主要展示函数调用以及内存分配的大概过程。  

因为javascript是单线程，所以所有的被执行的函数以及函数的参数和局部变量都会被推入到同一栈内存中，
这也就是大量递归会导致栈溢出（Stack overflow）的原因。

### 储存变量（Store variables）

当javascript程序运行时，在非全局作用域中产生的局部变量均储存在栈内存中。但是只有原始类型的变量真正的
存储在栈内存中。而引用类型的变量只是在栈内存中存储一个引用，这个引用指向堆内存的里的才是真正的值。
> 原始类型又称为基本类型，包括`string`、`number`、`bigint`、`boolean`、和`symbol`。虽然typeof null返回的是object
但是null真不是一个对象，这完全是javascript的官方bug。    
  
> 引用类型 是除了原始类型之外的类型，包括但不限于`Object`、`Array`、`Function`、`Date`、`RegExp`、`String`、
`Number`等等...因为其他引用类型都继承自object所以可以说所有的引用类型都是对象。  

   <el-alert
       title="全局变量以及被闭包引用的变量（即使是原始类型）均储存在堆内存中。"
       type="warning"
       :closable="false"
       ></el-alert>    
       
  <el-alert
    title="全局变量-在全局作用域下创建的所有变量都会成为全局对象（如 window 对象）的属性，也就是全局变量。
           而全局对象储存在堆内存中，所以全局变量必然也会储存在堆内存中。"
    type="warning"
    :closable="false"
    ></el-alert>   
     
   <el-alert
        title="闭包-当一个局部变量被当前函数之外的其他函数所引用（也就是发生了逃逸），此时这个局部变量就不能随着当前函数的返回而被回收，那么这个变量就必须储存在堆内存中"
        type="warning"
        :closable="false"
        ></el-alert>   
        
### 不可变与可变（Immutable and Mutable）
栈内存中会存储原始值和引用，不仅类型不同，他们在栈内存的表现也不太一样。

*原始类型*
* 当我们定义一个原始类型会开辟一个一块新的空间存变量的值
* 当我们给变量赋值为另一个新值时，栈内存依然会开辟一个新的空间给变量保存值。
* 当一个边赋值给另一个变量时依然是会开辟一个新的空间  
<img :src="$withBase('/img/memory/immutable.jpg')" alt="不可变例子">  
<el-alert
        title="所以说：栈内存中的原始值一旦确定就不能被更改（不可变的）"
        type="warning"
        :closable="false"
        ></el-alert> 

*对象引用*
* 当我们定义一个引用类型的变量时，JavaScript 会先在堆内存中找到一块合适的地方来储存对象，并激活一块栈内存来储存对象的引用（堆内存地址），最后将变量指向这块栈内存。
* 当我们把引用类型变量赋值给另一个变量时，会将源变量指向的栈内存中的对象引用复制到新变量的栈内存中，所以实际上只是复制了个对象引用，并没有在堆内存中生成一份新的对象。
* 而当我们给引用类型变量分配为一个新的对象时，则会直接修改变量指向的栈内存中的引用，新的引用指向堆内存中新的对象。
<img :src="$withBase('/img/memory/mutable.jpg')" alt="可变例子">  
<el-alert
        title="栈内存中的对象引用是可以被更改的（可变的）"
        type="warning"
        :closable="false"
        ></el-alert> 

### 内存的生命周期（Memory life cycle）
通常来说内存的声明周期都是一致的`分配 -> 使用 -> 释放`。对于 JavaScript 程序来说，内存的分配与释放是由 JavaScript 引擎自动完成的（目前的 JavaScript 引擎基本都是使用 C++ 或 C 编写的）。
但是这不意味着我们就不需要在乎内存管理，了解内存的更多细节可以帮助我们写出性能更好，稳定性更高的代码。
   
### 垃圾回收（Garbage collection）
垃圾回收即我们常说的 GC（Garbage collection），也就是清除内存中不再需要的数据，释放内存空间。
`由于栈内存由操作系统直接管理，所以当我们提到 GC 时指的都是堆内存的垃圾回收。`
基本上现在的浏览器的 JavaScript 引擎（如 V8 和 SpiderMonkey）都实现了垃圾回收机制，引擎中的垃圾回收器（Garbage collector）会定期进行垃圾回收。   

想要了解垃圾回收机制  我们先来理解两个概念`可达性`和`内存泄漏`。
> 可达性（Reachability）是指可直接或者间接通过全局对象访问到。  
<img :src="$withBase('/img/memory/kedaxing.jpg')" alt="可达性">  
上图中的节点 9 和节点 10 均无法通过节点 1（根节点）直接或间接访问，所以它们都是不可达的，可以被安全地回收。  
   
     
> 内存泄漏是指没用的数据因为某种原因而未被释放。     


        
        
  
  
  
    
